"use strict";(self.webpackChunkbiofile_finder=self.webpackChunkbiofile_finder||[]).push([[228],{9228:(t,e,r)=>{r.r(e),r.d(e,{Array:()=>Y,FetchStore:()=>_t,Group:()=>B,KeyError:()=>a,Location:()=>R,NodeNotFoundError:()=>n,_internal_get_array_context:()=>F,create:()=>V,get:()=>ot,open:()=>D,registry:()=>M,root:()=>j,set:()=>ct,slice:()=>H,tryWithConsolidated:()=>K,withConsolidated:()=>G});class n extends Error{constructor(t,e={}){super(`Node not found: ${t}`,e),this.name="NodeNotFoundError"}}class a extends Error{constructor(t){super(`Missing key: ${t}`),this.name="KeyError"}}class s{#t;constructor(t,e,r){"number"==typeof t?this.#t=new Uint8Array(t):t instanceof ArrayBuffer?this.#t=new Uint8Array(t,e,r):this.#t=new Uint8Array(Array.from(t,(t=>t?1:0)))}get BYTES_PER_ELEMENT(){return 1}get byteOffset(){return this.#t.byteOffset}get byteLength(){return this.#t.byteLength}get buffer(){return this.#t.buffer}get length(){return this.#t.length}get(t){let e=this.#t[t];return"number"==typeof e?0!==e:e}set(t,e){this.#t[t]=e?1:0}fill(t){this.#t.fill(t?1:0)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}class i{_data;chars;#e;constructor(t,e,r,n){if(this.chars=t,this.#e=new TextEncoder,"number"==typeof e)this._data=new Uint8Array(e*t);else if(e instanceof ArrayBuffer)n&&(n*=t),this._data=new Uint8Array(e,r,n);else{let r=Array.from(e);this._data=new Uint8Array(r.length*t);for(let t=0;t<r.length;t++)this.set(t,r[t])}}get BYTES_PER_ELEMENT(){return this.chars}get byteOffset(){return this._data.byteOffset}get byteLength(){return this._data.byteLength}get buffer(){return this._data.buffer}get length(){return this.byteLength/this.BYTES_PER_ELEMENT}get(t){const e=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);return(new TextDecoder).decode(e).replace(/\x00/g,"")}set(t,e){const r=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);r.fill(0),r.set(this.#e.encode(e))}fill(t){const e=this.#e.encode(t);for(let t=0;t<this.length;t++)this._data.set(e,t*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}class o{#r;chars;constructor(t,e,r,n){if(this.chars=t,"number"==typeof e)this.#r=new Int32Array(e*t);else if(e instanceof ArrayBuffer)n&&(n*=t),this.#r=new Int32Array(e,r,n);else{const r=e,n=new o(t,1);this.#r=new Int32Array(function*(){for(let t of r)n.set(0,t),yield*n.#r}())}}get BYTES_PER_ELEMENT(){return this.#r.BYTES_PER_ELEMENT*this.chars}get byteLength(){return this.#r.byteLength}get byteOffset(){return this.#r.byteOffset}get buffer(){return this.#r.buffer}get length(){return this.#r.length/this.chars}get(t){const e=this.chars*t;let r="";for(let t=0;t<this.chars;t++)r+=String.fromCodePoint(this.#r[e+t]);return r.replace(/\u0000/g,"")}set(t,e){const r=this.chars*t,n=this.#r.subarray(r,r+this.chars);n.fill(0);for(let t=0;t<this.chars;t++)n[t]=e.codePointAt(t)??0}fill(t){this.set(0,t);let e=this.#r.subarray(0,this.chars);for(let t=1;t<this.length;t++)this.#r.set(e,t*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}function c(t){const e=JSON.stringify(t,null,2);return(new TextEncoder).encode(e)}function u(t){const e=(new TextDecoder).decode(t);return JSON.parse(e)}function h(t,e){const r=e/2,n=e-1;let a=0;for(let s=0;s<t.length;s+=e)for(let e=0;e<r;e+=1)a=t[s+e],t[s+e]=t[s+n-e],t[s+n-e]=a}const d={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:globalThis.BigInt64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:globalThis.BigUint64Array,float32:Float32Array,float64:Float64Array,bool:s},l=/v2:([US])(\d+)/;function f(t){if("v2:object"===t)return globalThis.Array;let e=t.match(l);if(e){let[,t,r]=e;return("U"===t?o:i).bind(null,Number(r))}let r=d[t];if(!r)throw new Error(`Unknown or unsupported data_type: ${t}`);return r}function y(t,e){return("C"===e?_:p)(t)}function _(t){const e=t.length,r=globalThis.Array(e);for(let n=e-1,a=1;n>=0;n--)r[n]=a,a*=t[n];return r}function p(t){const e=t.length,r=globalThis.Array(e);for(let n=0,a=1;n<e;n++)r[n]=a,a*=t[n];return r}function g({name:t,configuration:e}){if("default"===t){const t=e?.separator??"/";return e=>["c",...e].join(t)}if("v2"===t){const t=e?.separator??".";return e=>e.join(t)||"0"}throw new Error(`Unknown chunk key encoding: ${t}`)}function m(t){const e=t.find((t=>"transpose"===t.name));return"F"===e?.configuration?.order?"F":"C"}const b=/^([<|>])(.*)$/;function w(t){return"sharding_indexed"===t?.name}function k(t){return"uint64"!==t.data_type&&"int64"!==t.data_type||null==t.fill_value?t.fill_value:BigInt(t.fill_value)}const E=function(){const t=new Uint32Array([305419896]);return!(18===new Uint8Array(t.buffer,t.byteOffset,t.byteLength)[0])}();function v(t){return"BYTES_PER_ELEMENT"in t?t.BYTES_PER_ELEMENT:4}class A{kind="array_to_bytes";#n;#a;#s;#i;#o;constructor(t,e){this.#o=t.endian,this.#a=f(e.data_type),this.#i=e.shape,this.#n=y(e.shape,m(e.codecs));const r=new this.#a(0);this.#s=r.BYTES_PER_ELEMENT}static fromConfig(t,e){return new A(t,e)}encode(t){let e=new Uint8Array(t.data.buffer);return E&&"big"===this.#o&&h(e,v(this.#a)),e}decode(t){return E&&"big"===this.#o&&h(t,v(this.#a)),{data:new this.#a(t.buffer,t.byteOffset,t.byteLength/this.#s),shape:this.#i,stride:this.#n}}}class T{kind="bytes_to_bytes";static fromConfig(){return new T}encode(t){throw new Error("Not implemented")}decode(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength-4)}}function x(t,e){if(Number.isNaN(e))throw new Error("JsonCodec allow_nan is false but NaN was encountered during encoding.");if(e===Number.POSITIVE_INFINITY)throw new Error("JsonCodec allow_nan is false but Infinity was encountered during encoding.");if(e===Number.NEGATIVE_INFINITY)throw new Error("JsonCodec allow_nan is false but -Infinity was encountered during encoding.");return e}function N(t,e){return e instanceof Object&&!Array.isArray(e)?Object.keys(e).sort().reduce(((t,r)=>(t[r]=e[r],t)),{}):e}class U{configuration;kind="array_to_bytes";#c;#u;constructor(t){this.configuration=t;const{encoding:e="utf-8",skipkeys:r=!1,ensure_ascii:n=!0,check_circular:a=!0,allow_nan:s=!0,sort_keys:i=!0,indent:o,strict:c=!0}=t;let u=t.separators;u||(u=o?[", ",": "]:[",",":"]),this.#c={encoding:e,skipkeys:r,ensure_ascii:n,check_circular:a,allow_nan:s,indent:o,separators:u,sort_keys:i},this.#u={strict:c}}static fromConfig(t){return new U(t)}encode(t){const{indent:e,encoding:r,ensure_ascii:n,check_circular:a,allow_nan:s,sort_keys:i}=this.#c;if("utf-8"!==r)throw new Error("JsonCodec does not yet support non-utf-8 encoding.");const o=[];if(!a)throw new Error("JsonCodec does not yet support skipping the check for circular references during encoding.");s||o.push(x),i&&o.push(N);const c=Array.from(t.data);let u;c.push("|O"),c.push(t.shape),o.length&&(u=(t,e)=>{let r=e;for(let e of o)r=e(t,r);return r});let h=JSON.stringify(c,u,e);return n&&(h=h.replace(/[\u007F-\uFFFF]/g,(t=>{const e=`0000${t.charCodeAt(0).toString(16)}`;return`\\u${e.substring(e.length-4)}`}))),(new TextEncoder).encode(h)}decode(t){const{strict:e}=this.#u;if(!e)throw new Error("JsonCodec does not yet support non-strict decoding.");const r=u(t),n=r.pop();if(r.pop(),!n)throw new Error("0D not implemented for JsonCodec.");return{data:r,shape:n,stride:y(n,"C")}}}function C(t){return t instanceof s||t instanceof i||t instanceof o?new Proxy(t,{get:(t,e)=>t.get(Number(e)),set:(t,e,r)=>(t.set(Number(e),r),!0)}):t}class S{configuration;kind="array_to_array";constructor(t){this.configuration=t}static fromConfig(t){return new S(t)}encode(t){return function(t){if(!t.stride)return"C";let e=y(t.shape,"C");return t.stride.every(((t,r)=>t===e[r]))?"C":"F"}(t)===this.configuration.order?t:function(t,e){let r=function(t,e){let r;return r=t.data instanceof i||t.data instanceof o?new t.constructor(t.data.length,t.data.chars):new t.constructor(t.data.length),{data:r,shape:t.shape,stride:y(t.shape,e)}}(t,e),n=t.shape.length,a=t.data.length,s=Array(n).fill(0),c=C(t.data),u=C(r.data);for(let e=0;e<a;e++){let a=0;for(let t=0;t<n;t++)a+=s[t]*r.stride[t];u[a]=c[e],s[0]+=1;for(let e=0;e<n;e++)if(s[e]===t.shape[e]){if(e+1===n)break;s[e]=0,s[e+1]+=1}}return r}(t,this.configuration.order)}decode(t){return t}}class L{kind="array_to_bytes";#i;#n;constructor(t){this.#i=t,this.#n=y(t,"C")}static fromConfig(t,e){return new L(e.shape)}encode(t){throw new Error("Method not implemented.")}decode(t){let e=new TextDecoder,r=new DataView(t.buffer),n=Array(r.getUint32(0,!0)),a=4;for(let s=0;s<n.length;s++){let i=r.getUint32(a,!0);a+=4,n[s]=e.decode(t.buffer.slice(a,a+i)),a+=i}return{data:n,shape:this.#i,stride:this.#n}}}const M=(new Map).set("blosc",(()=>r.e(634).then(r.bind(r,7634)).then((t=>t.default)))).set("gzip",(()=>Promise.all([r.e(302),r.e(691)]).then(r.bind(r,3691)).then((t=>t.default)))).set("lz4",(()=>r.e(829).then(r.bind(r,8829)).then((t=>t.default)))).set("zlib",(()=>Promise.all([r.e(302),r.e(550)]).then(r.bind(r,9550)).then((t=>t.default)))).set("zstd",(()=>r.e(580).then(r.bind(r,9580)).then((t=>t.default)))).set("transpose",(()=>S)).set("bytes",(()=>A)).set("crc32c",(()=>T)).set("vlen-utf8",(()=>L)).set("json2",(()=>U));function z(t){let e;return{async encode(r){e||(e=await I(t));for(const t of e.array_to_array)r=await t.encode(r);let n=await e.array_to_bytes.encode(r);for(const t of e.bytes_to_bytes)n=await t.encode(n);return n},async decode(r){e||(e=await I(t));for(let t=e.bytes_to_bytes.length-1;t>=0;t--)r=await e.bytes_to_bytes[t].decode(r);let n=await e.array_to_bytes.decode(r);for(let t=e.array_to_array.length-1;t>=0;t--)n=await e.array_to_array[t].decode(n);return n}}}async function I(t){let e,r=t.codecs.map((async t=>{let e=await(M.get(t.name)?.());if(!e)throw new Error(`Unknown codec: ${t.name}`);return{Codec:e,meta:t}})),n=[],a=[];for await(let{Codec:s,meta:i}of r){let r=s.fromConfig(i.configuration,t);switch(r.kind){case"array_to_array":n.push(r);break;case"array_to_bytes":e=r;break;default:a.push(r)}}if(!e){if("v2:object"===t.data_type)throw new Error(`Cannot encode ${t.data_type} to bytes without a codec`);e=A.fromConfig({endian:"little"},t)}return{array_to_array:n,array_to_bytes:e,bytes_to_bytes:a}}const $=18446744073709551615n;function O(t,e,r,n){if(void 0===t.store.getRange)throw new Error("Store does not support range requests");let a=t.store.getRange.bind(t.store),s=e.map(((t,e)=>t/n.chunk_shape[e])),i=z({data_type:"uint64",shape:[...s,2],codecs:n.index_codecs}),o={};return async e=>{let n,c=e.map(((t,e)=>Math.floor(t/s[e]))),u=t.resolve(r(c)).path;if(u in o)n=o[u];else{let t=4,e=16*s.reduce(((t,e)=>t*e),1),r=await a(u,{suffixLength:e+t});n=o[u]=r?await i.decode(r):null}if(null===n)return;let{data:h,shape:d,stride:l}=n,f=e.map(((t,e)=>t%d[e])).reduce(((t,e,r)=>t+e*l[r]),0),y=h[f],_=h[f+1];return y!==$||_!==$?a(u,{offset:Number(y),length:Number(_)}):void 0}}class R{store;path;constructor(t,e="/"){this.store=t,this.path=e}resolve(t){let e=new URL(`file://${this.path.endsWith("/")?this.path:`${this.path}/`}`);return new R(this.store,new URL(t,e).pathname)}}function j(t){return new R(t??new Map)}class B extends R{kind="group";#h;constructor(t,e,r){super(t,e),this.#h=r}get attrs(){return this.#h.attributes}}const P=Symbol("zarrita.context");function F(t){return t[P]}class Y extends R{kind="array";#h;[P];constructor(t,e,r){super(t,e),this.#h={...r,fill_value:k(r)},this[P]=function(t,e){let{configuration:r}=e.codecs.find(w)??{},n={encode_chunk_key:g(e.chunk_key_encoding),TypedArray:f(e.data_type),fill_value:e.fill_value};if(r){let a=m(r.codecs);return{...n,kind:"sharded",chunk_shape:r.chunk_shape,codec:z({data_type:e.data_type,shape:r.chunk_shape,codecs:r.codecs}),get_strides:(t,e)=>y(t,e??a),get_chunk_bytes:O(t,e.chunk_grid.configuration.chunk_shape,n.encode_chunk_key,r)}}let a=m(e.codecs);return{...n,kind:"regular",chunk_shape:e.chunk_grid.configuration.chunk_shape,codec:z({data_type:e.data_type,shape:e.chunk_grid.configuration.chunk_shape,codecs:e.codecs}),get_strides:(t,e)=>y(t,e??a),async get_chunk_bytes(e,r){let a=n.encode_chunk_key(e),s=t.resolve(a).path;return t.store.get(s,r)}}}(this,r)}get attrs(){return this.#h.attributes}get shape(){return this.#h.shape}get chunks(){return this[P].chunk_shape}get dtype(){return this.#h.data_type}async getChunk(t,e){let r=this[P],n=await r.get_chunk_bytes(t,e);if(!n){let t=r.chunk_shape.reduce(((t,e)=>t*e),1),e=new r.TypedArray(t);return e.fill(r.fill_value),{data:e,shape:r.chunk_shape,stride:r.get_strides(r.chunk_shape)}}return r.codec.decode(n)}is(t){return function(t,e){if("number"!==e&&"bigint"!==e&&"boolean"!==e&&"object"!==e&&"string"!==e)return t===e;let r="bool"===t;if("boolean"===e)return r;let n=t.startsWith("v2:U")||t.startsWith("v2:S");if("string"===e)return n;let a="int64"===t||"uint64"===t;if("bigint"===e)return a;let s="v2:object"===t;return"object"===e?s:!(n||a||r||s)}(this.dtype,t)}}let W=function(){let t=new WeakMap;function e(e){let r=t.get(e)??{v2:0,v3:0};return t.set(e,r),r}return{increment(t,r){e(t)[r]+=1},version_max(t){let r=e(t);return r.v3>r.v2?"v3":"v2"}}}();async function J(t,e){let{path:r}=t.resolve(".zarray"),s=await t.store.get(r);if(!s)throw new n("v2 array",{cause:new a(r)});return W.increment(t.store,"v2"),new Y(t.store,t.path,function(t,e={}){let r=[],n=function(t){if("|O"===t)return{data_type:"v2:object"};let e=t.match(b);if(!e)throw new Error(`Invalid dtype: ${t}`);let[,r,n]=e,a={b1:"bool",i1:"int8",u1:"uint8",i2:"int16",u2:"uint16",i4:"int32",u4:"uint32",i8:"int64",u8:"uint64",f4:"float32",f8:"float64"}[n]??(n.startsWith("S")||n.startsWith("U")?`v2:${n}`:void 0);if(!a)throw new Error(`Unsupported or unknown dtype: ${t}`);return"|"===r?{data_type:a}:{data_type:a,endian:"<"===r?"little":"big"}}(t.dtype);"F"===t.order&&r.push({name:"transpose",configuration:{order:"F"}}),"endian"in n&&"big"===n.endian&&r.push({name:"bytes",configuration:{endian:"big"}});for(let{id:e,...n}of t.filters??[])r.push({name:e,configuration:n});if(t.compressor){let{id:e,...n}=t.compressor;r.push({name:e,configuration:n})}return{zarr_format:3,node_type:"array",shape:t.shape,data_type:n.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:t.chunks}},chunk_key_encoding:{name:"v2",configuration:{separator:t.dimension_separator??"."}},codecs:r,fill_value:t.fill_value,attributes:e}}(u(s),e))}async function q(t,e){let{path:r}=t.resolve(".zgroup"),s=await t.store.get(r);if(!s)throw new n("v2 group",{cause:new a(r)});return W.increment(t.store,"v2"),new B(t.store,t.path,function(t,e={}){return{zarr_format:3,node_type:"group",attributes:e}}(u(s),e))}async function D(t,e={}){let r="store"in t?t.store:t,a=W.version_max(r),s="v2"===a?D.v2:D.v3,i="v2"===a?D.v3:D.v2;return s(t,e).catch((r=>{if(r instanceof n)return i(t,e);throw r}))}async function V(t,e={}){let r="store"in t?t:new R(t);if("shape"in e){let t=await async function(t,e){let r={zarr_format:3,node_type:"array",shape:e.shape,data_type:e.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:e.chunk_shape}},chunk_key_encoding:{name:"default",configuration:{separator:e.chunk_separator??"/"}},codecs:e.codecs??[],fill_value:e.fill_value??null,attributes:e.attributes??{}};return await t.store.set(t.resolve("zarr.json").path,c(r)),new Y(t.store,t.path,r)}(r,e);return t}return async function(t,e={}){let r={zarr_format:3,node_type:"group",attributes:e.attributes??{}};return await t.store.set(t.resolve("zarr.json").path,c(r)),new B(t.store,t.path,r)}(r,e)}async function G(t){let e=await async function(t){let e=await t.get("/.zmetadata");if(!e)throw new n("v2 consolidated metadata",{cause:new a("/.zmetadata")});let r=u(e);if(1!==r.zarr_consolidated_format)throw new Error("Unsupported consolidated format.");return r}(t),r={};for(let[t,n]of Object.entries(e.metadata))r[`/${t}`]=n;return{async get(...e){let[n,a]=e;if(r[n])return c(r[n]);let s=await t.get(n,a);if(function(t){return t.endsWith(".zarray")||t.endsWith(".zgroup")||t.endsWith(".zattrs")||t.endsWith("zarr.json")}(n)&&s){let t=u(s);r[n]=t}return s},contents(){let t=[];for(let[n,a]of Object.entries(r)){let r=n.split("/"),s=r.pop(),i=r.join("/")||"/";".zarray"===s&&t.push({path:i,kind:"array"}),".zgroup"===s&&t.push({path:i,kind:"group"}),"zarr_format"in(e=a)&&3===e.zarr_format&&t.push({path:i,kind:a.node_type})}var e;return t}}}async function K(t){return G(t).catch((e=>{if(e instanceof n)return t;throw e}))}function H(t,e,r=null){return void 0===e&&(e=t,t=null),{start:t,stop:e,step:r}}function Q(){const t=[];return{add:e=>t.push(e()),onIdle:()=>Promise.all(t)}}D.v2=async function(t,e={}){let r="store"in t?t:new R(t),a={};return(e.attrs??1)&&(a=await async function(t){let e=await t.store.get(t.resolve(".zattrs").path);return e?u(e):{}}(r)),"array"===e.kind?J(r,a):"group"===e.kind?q(r,a):J(r,a).catch((t=>{if(t instanceof n)return q(r,a);throw t}))},D.v3=async function(t,e={}){let r="store"in t?t:new R(t),s=await async function(t){let{store:e,path:r}=t.resolve("zarr.json"),s=await t.store.get(r);if(!s)throw new n("v3 array or group",{cause:new a(r)});let i=u(s);return"array"===i.node_type&&(i.fill_value=k(i)),"array"===i.node_type?new Y(e,t.path,i):new B(e,t.path,i)}(r);if(W.increment(r.store,"v3"),void 0===e.kind)return s;if("array"===e.kind&&s instanceof Y)return s;if("group"===e.kind&&s instanceof B)return s;let i=s instanceof Y?"array":"group";throw new Error(`Expected node of kind ${e.kind}, found ${i}.`)};class X extends Error{constructor(t){super(t),this.name="IndexError"}}class Z{dim_sel;dim_len;dim_chunk_len;nitems;constructor({dim_sel:t,dim_len:e,dim_chunk_len:r}){t=function(t,e){return(t=Math.trunc(t))<0&&(t=e+t),(t>=e||t<0)&&function(t){throw new X(`index out of bounds for dimension with length ${t}`)}(e),t}(t,e),this.dim_sel=t,this.dim_len=e,this.dim_chunk_len=r,this.nitems=1}*[Symbol.iterator](){const t=Math.floor(this.dim_sel/this.dim_chunk_len),e=t*this.dim_chunk_len,r=this.dim_sel-e;yield{dim_chunk_ix:t,dim_chunk_sel:r}}}class tt{start;stop;step;dim_len;dim_chunk_len;nitems;nchunks;constructor({dim_sel:t,dim_len:e,dim_chunk_len:r}){const[n,a,s]=function({start:t,stop:e,step:r},n){if(0===r)throw new Error("slice step cannot be zero");const a=(r=r??1)<0,[s,i]=a?[-1,n-1]:[0,n];return null===t?t=a?i:s:t<0?(t+=n)<s&&(t=s):t>i&&(t=i),null===e?e=a?s:i:e<0?(e+=n)<s&&(e=s):e>i&&(e=i),[t,e,r]}(t,e);this.start=n,this.stop=a,this.step=s,this.step<1&&function(){throw new X("only slices with step >= 1 are supported")}(),this.dim_len=e,this.dim_chunk_len=r,this.nitems=Math.max(0,Math.ceil((this.stop-this.start)/this.step)),this.nchunks=Math.ceil(this.dim_len/this.dim_chunk_len)}*[Symbol.iterator](){const t=Math.floor(this.start/this.dim_chunk_len),e=Math.ceil(this.stop/this.dim_chunk_len);for(const r of function*(t,e,r=1){void 0===e&&(e=t,t=0);for(let n=t;n<e;n+=r)yield n}(t,e)){const t=r*this.dim_chunk_len,e=Math.min(this.dim_len,(r+1)*this.dim_chunk_len),n=e-t;let a=0,s=0;if(this.start<t){const e=(t-this.start)%this.step;e&&(s+=this.step-e),a=Math.ceil((t-this.start)/this.step)}else s=this.start-t;const i=this.stop>e?n:this.stop-t,o=[s,i,this.step],c=[a,a+Math.ceil((i-s)/this.step),1];yield{dim_chunk_ix:r,dim_chunk_sel:o,dim_out_sel:c}}}}class et{dim_indexers;shape;constructor({selection:t,shape:e,chunk_shape:r}){this.dim_indexers=function(t,e){let r=[];return null===t?r=e.map((t=>H(null))):Array.isArray(t)&&(r=t.map((t=>t??H(null)))),function(t,e){t.length>e.length&&function(t,e){throw new X(`too many indicies for array; expected ${e.length}, got ${t.length}`)}(t,e)}(r,e),r}(t,e).map(((t,n)=>new("number"==typeof t?Z:tt)({dim_sel:t,dim_len:e[n],dim_chunk_len:r[n]}))),this.shape=this.dim_indexers.filter((t=>t instanceof tt)).map((t=>t.nitems))}*[Symbol.iterator](){for(const t of function*(...t){if(0===t.length)return;const e=t.map((t=>t[Symbol.iterator]())),r=e.map((t=>t.next()));if(r.some((t=>t.done)))throw new Error("Input contains an empty iterator.");for(let n=0;;){if(r[n].done){if(e[n]=t[n][Symbol.iterator](),r[n]=e[n].next(),++n>=e.length)return}else yield r.map((({value:t})=>t)),n=0;r[n]=e[n].next()}}(...this.dim_indexers)){const e=t.map((t=>t.dim_chunk_ix)),r=t.map((t=>"dim_out_sel"in t?{from:t.dim_chunk_sel,to:t.dim_out_sel}:{from:t.dim_chunk_sel,to:null}));yield{chunk_coords:e,mapping:r}}}}function rt(t){return t.to,{from:t.to,to:t.from}}function nt(t,e){return t.every(((t,r)=>{if("number"==typeof t)return!1;const[n,a,s]=t;return a-n===e[r]&&1===s}))}function at(t,e=0,r){let n=r??t.length-e;return{length:n,subarray:(r,a=n)=>at(t,e+r,a-r),set(r,n=0){for(let a=0;a<r.length;a++)t[e+n+a]=r.get(a)},get:r=>t[e+r]}}function st(t){return globalThis.Array.isArray(t.data)?{data:at(t.data),stride:t.stride,bytes_per_element:1}:{data:new Uint8Array(t.data.buffer,t.data.byteOffset,t.data.byteLength),stride:t.stride,bytes_per_element:t.data.BYTES_PER_ELEMENT}}const it={prepare:(t,e,r)=>({data:t,shape:e,stride:r}),set_scalar(t,e,r){let n=st(t);ht(n,e,function(t,e){if(globalThis.Array.isArray(t.data))return at([e]);let r=new(function(t){return"chars"in t?t.constructor.bind(null,t.chars):t.constructor}(t.data))([e]);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}(t,r),n.bytes_per_element)},set_from_chunk(t,e,r){let n=st(t);dt(n,st(e),n.bytes_per_element,r)}};async function ot(t,e=null,r={}){return async function(t,e,r,n){let a=F(t),s=new et({selection:e,shape:t.shape,chunk_shape:t.chunks}),i=n.prepare(new a.TypedArray(s.shape.reduce(((t,e)=>t*e),1)),s.shape,a.get_strides(s.shape,r.order)),o=r.create_queue?.()??Q();for(const{chunk_coords:e,mapping:a}of s)o.add((async()=>{let{data:s,shape:o,stride:c}=await t.getChunk(e,r.opts),u=n.prepare(s,o,c);n.set_from_chunk(i,u,a)}));return await o.onIdle(),0===s.shape.length?function(t){return"get"in t?t.get(0):t[0]}(i.data):i}(t,e,r,it)}async function ct(t,e,r,n={}){return async function(t,e,r,n,a){const s=F(t);if("sharded"===s.kind)throw new Error("Set not supported for sharded arrays.");const i=new et({selection:e,shape:t.shape,chunk_shape:t.chunks}),o=t.chunks.reduce(((t,e)=>t*e),1),c=n.create_queue?n.create_queue():Q();for(const{chunk_coords:e,mapping:n}of i){const i=n.map((t=>t.from)),u=n.map(rt);c.add((async()=>{const n=t.resolve(s.encode_chunk_key(e)).path;let c;const h=t.chunks.slice(),d=s.get_strides(h);if(nt(i,h))if(c=new s.TypedArray(o),"object"==typeof r){const t=a.prepare(c,h.slice(),d.slice());a.set_from_chunk(t,r,u)}else c.fill(r);else{c=await t.getChunk(e).then((({data:t})=>t));const n=a.prepare(c,h.slice(),d.slice());"object"==typeof r?a.set_from_chunk(n,r,u):a.set_scalar(n,i,r)}await t.store.set(n,await s.codec.encode({data:c,shape:h,stride:d}))}))}await c.onIdle()}(t,e,r,n,it)}function ut(t,e,r){return r<0&&e<t?Math.floor((t-e-1)/-r)+1:t<e?Math.floor((e-t-1)/r)+1:0}function ht(t,e,r,n){if(0===e.length)return void t.data.set(r,0);const[a,...s]=e,[i,...o]=t.stride;if("number"==typeof a)return void ht({data:t.data.subarray(i*a*n),stride:o},s,r,n);const[c,u,h]=a,d=ut(c,u,h);if(0!==s.length)for(let e=0;e<d;e++)ht({data:t.data.subarray(i*(c+h*e)*n),stride:o},s,r,n);else for(let e=0;e<d;e++)t.data.set(r,i*(c+h*e)*n)}function dt(t,e,r,n){const[a,...s]=n,[i,...o]=t.stride,[c,...u]=e.stride;if(null===a.from)return 0===s.length?void t.data.set(e.data.subarray(0,r),a.to*r):void dt({data:t.data.subarray(i*a.to*r),stride:o},e,r,s);if(null===a.to){if(0===s.length){let n=a.from*r;return void t.data.set(e.data.subarray(n,n+r),0)}return void dt(t,{data:e.data.subarray(c*a.from*r),stride:u},r,s)}const[h,d,l]=a.to,[f,y,_]=a.from,p=ut(h,d,l);if(0!==s.length)for(let n=0;n<p;n++)dt({data:t.data.subarray(i*(h+n*l)*r),stride:o},{data:e.data.subarray(c*(f+n*_)*r),stride:u},r,s);else{if(1===l&&1===_&&1===i&&1===c){let n=f*r,a=p*r;return void t.data.set(e.data.subarray(n,n+a),h*r)}for(let n=0;n<p;n++){let a=c*(f+_*n)*r;t.data.set(e.data.subarray(a,a+r),i*(h+l*n)*r)}}}function lt(t,e,r,n={}){return void 0!==e&&void 0!==r&&(n={...n,headers:{...n.headers,Range:`bytes=${e}-${e+r-1}`}}),fetch(t,n)}function ft(t,e){const r="string"==typeof t?new URL(t):t;r.pathname.endsWith("/")||(r.pathname+="/");const n=new URL(e.slice(1),r);return n.search=r.search,n}async function yt(t){if(404!==t.status&&403!==t.status){if(200===t.status||206===t.status)return new Uint8Array(await t.arrayBuffer());throw new Error(`Unexpected response status ${t.status} ${t.statusText}`)}}const _t=class{url;#d;#l;constructor(t,e={}){this.url=t,this.#d=e.overrides??{},this.#l=e.useSuffixRequest??!1}#f(t){return e=this.#d,r=t,{...e,...r,headers:{...e.headers,...r.headers}};var e,r}async get(t,e={}){let r=ft(this.url,t).href;return yt(await fetch(r,this.#f(e)))}async getRange(t,e,r={}){let n,a=ft(this.url,t),s=this.#f(r);return n="suffixLength"in e?await async function(t,e,r,n){if(n)return fetch(t,{...r,headers:{...r.headers,Range:`bytes=-${e}`}});let a=await fetch(t,{...r,method:"HEAD"});if(!a.ok)return a;let s=a.headers.get("Content-Length"),i=Number(s);return lt(t,i-e,i,r)}(a,e.suffixLength,s,this.#l):await lt(a,e.offset,e.length,s),yt(n)}}}}]);